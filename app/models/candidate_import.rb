# frozen_string_literal: true

#
# A helper class used for importing and exporting the DB information.
#
class CandidateImport
  extend ActiveModel::Naming
  include ActiveModel::Conversion
  include ActiveModel::Validations
  include FileHelper

  attr_accessor :uploaded_file
  attr_accessor :uploaded_zip_file
  attr_accessor :imported_candidates
  # check_events
  attr_accessor :missing_confirmation_events
  attr_accessor :found_confirmation_events
  attr_accessor :unknown_confirmation_events
  # orphaned table rows
  attr_accessor :orphaned_table_rows
  attr_accessor :candidate_missing_associations

  def self.image_columns
    %w[
      baptismal_certificate.scanned_certificate retreat_verification.scanned_retreat sponsor_covenant.scanned_eligibility sponsor_covenant.scanned_covenant
    ]
  end

  def self.transient_columns
    %w[
      baptismal_certificate.certificate_picture baptismal_certificate.remove_certificate_picture
      retreat_verification.retreat_verification_picture retreat_verification.remove_retreat_verification_picture
      sponsor_covenant.sponsor_eligibility_picture sponsor_covenant.sponsor_covenant_picture
      sponsor_covenant.remove_sponsor_eligibility_picture sponsor_covenant.remove_sponsor_covenant_picture
    ]
  end

  # initialize new instance
  #
  # === Parameters:
  #
  # * <tt>:_attributes_</tt> name vaue pairs
  #
  # === Return:
  #
  # Hash of information to be verified
  #
  def initialize(attributes = {})
    attributes.each { |name, value| send("#{name}=", value) }
    @worksheet_conf_event_name = 'Confirmation Events'
    @worksheet_name = 'Candidates with events'
    # check_events
    @found_confirmation_events = []
    @missing_confirmation_events = []
    @unknown_confirmation_events = []

    @orphaned_table_rows = []
    @candidate_missing_associations = []
  end

  # filepath for exporting
  #
  # === Parameters:
  #
  # * <tt>:candidate</tt> Candidate: being exported
  # * <tt>:dir</tt> String: the directory
  # * <tt>:image_column</tt> Symbol: The ScannedImage accessor.
  # * <tt>:image</tt> ScannedImage: the image being exported
  #
  # === Return:
  #
  # String: the file path
  #
  def self.image_filepath_export(candidate, dir, image_column, image)
    file_basename = image.nil? ? '' : File.basename(image.filename)
    "#{dir}/#{candidate.account_name}_#{image_column}_#{file_basename}"
  end

  # File for importing
  #
  # === Parameters:
  #
  # * <tt>:file_path</tt> String: filepath for importing
  #
  # === Return:
  #
  # File: for file_path
  #
  def self.image_filename_import(file_path)
    filename = File.basename(file_path)
    filename
  end

  # Add events expectd to be missing
  #
  # === Parameters:
  #
  # * <tt>:missing_events</tt> Array: of expected missing ConfirmationEvents
  #
  # === Return:
  #
  # CandidateImport: self
  #
  def add_missing_events(missing_events)
    missing_events.each do |event_name|
      confirmation_event = ConfirmationEvent.find_by(name: event_name)
      AppFactory.add_confirmation_event(event_name) if confirmation_event.nil?
      raise "Attempting to candidate_event named: #{event_name} that already exists.s" unless confirmation_event.nil?
    end
    check_events
  end

  # Check to seeif any ConfirmaEvents are missing.  It stores missing store in unknown_confirmation_events
  #
  # === Return:
  #
  # CandidateImport: self
  #
  def check_events
    all_in_confirmation_event_names = AppFactory.all_i18n_confirmation_event_names
    unknowns = ConfirmationEvent.all.map(&:name)
    all_in_confirmation_event_names.each do |i18n_key|
      confirmation_event_name = I18n.t(i18n_key)
      unknowns_index = unknowns.index(confirmation_event_name)
      unknowns.slice!(unknowns_index) unless unknowns_index.nil?
      confirmation_event = ConfirmationEvent.find_by(name: confirmation_event_name)
      if confirmation_event.nil?
        missing_confirmation_events.push(confirmation_event_name)
      else
        found_confirmation_events.push(confirmation_event_name)
      end
    end
    unknowns.each do |confirmation_event_name|
      unknown_confirmation_events.push(confirmation_event_name)
    end
    self
  end

  # Load an excel file with initial list of candidates.  It can be loaded in multiple times
  #
  # === Parameters:
  #
  # * <tt>:file</tt> String: filepath
  #
  # === Return:
  #
  # Boolean:  whether valid
  #
  def load_initial_file(file)
    @uploaded_file = file
    @imported_candidates = load_imported_candidates
    ans = validate_and_save_import
    Rails.logger.info "done load_initial_file: #{file.original_filename}"
    ans
  end

  # Load a zip file generated by exporting
  #
  # === Parameters:
  #
  # * <tt>:file</tt> String: filepath
  #
  # === Return:
  #
  # Boolean: whether valid
  #
  def load_zip_file(file)
    @uploaded_zip_file = file
    @imported_candidates = load_imported_candidates
    ans = validate_and_save_import
    Rails.logger.info "done load_zip_file: #{file.path}"
    ans
  end

  # needed to expand _candidate_import.html.erb
  #
  # === Return:
  #
  # Boolean: false
  #
  def persisted?
    false
  end

  # Clear DB out for starting a new year.
  #
  def start_new_year
    clean_associations(Candidate)
    AppFactory.create_seed_candidate
    today = Date.today
    ConfirmationEvent.find_each do |ce|
      ce.chs_due_date = today
      ce.the_way_due_date = today
      ce.save
    end

    Rails.logger.info 'done start new year'
  end

  # Used to start a new year - cleans out tables for new year.
  #
  # === Parameters:
  #
  # * <tt>:clazz</tt> Class: class under consideration
  # * <tt>:checked</tt> Array: of class already checked
  # * <tt>:do_not_destroy</tt> Array: of class not to destroy table entries.
  #
  def clean_associations(clazz, checked = [], do_not_destroy = [Admin, ConfirmationEvent])
    return if (checked.include? clazz) || (do_not_destroy.include? clazz)
    checked << clazz
    begin
      clazz.destroy_all
    rescue StandardError => e
      Rails.logger.info "cleaning association error when destroying #{clazz}"
      Rails.logger.info e.message
      Rails.logger.info e.backtrace.inspect
    end
    clazz.reflect_on_all_associations.each do |assoc|
      clean_associations(assoc.klass, checked)
    end
  end

  # Reset the database.  End up with only an admin + confirmation events and the candidate vickikristoff
  #
  def reset_database
    start_new_year

    remove_all_confirmation_events

    Admin.find_each(&:delete)

    AppFactory.add_confirmation_events

    AppFactory.generate_seed
  end

  # exporting the DB tables to excel.
  #
  # === Parameters:
  #
  # * <tt>:dir</tt> String:  where to store the zip file.
  #
  # === Return:
  #
  # Package: package
  #
  def to_xlsx(dir, with_pictures = true)
    p = create_xlsx_package(dir, with_pictures)
    # the Package will be generated with a shared string table
    p.use_shared_strings = true
    p
  end

  # destroy orphaned rows
  #
  # === Return:
  #
  # CandidateImport: self
  #
  def remove_orphaned_table_rows
    cand_ids = ids(Candidate)
    orphaned_rows = orphaned_baptismal_certificates(cand_ids)
    BaptismalCertificate.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_candidate_sheets(cand_ids)
    CandidateSheet.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_christian_ministry(cand_ids)
    ChristianMinistry.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_pick_name(cand_ids)
    PickConfirmationName.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_retreat_verification(cand_ids)
    RetreatVerification.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_sponsor_covenant(cand_ids)
    SponsorCovenant.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_addresses
    Address.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_scanned_image
    ScannedImage.destroy(orphaned_rows) unless orphaned_rows.empty?
    orphaned_rows = orphaned_to_do
    ToDo.destroy(orphaned_rows) unless orphaned_rows.empty?

    @cache = nil
    self
  end

  # get & cache ids of clazz
  #
  # === Parameters:
  #
  # * <tt>:clazz</tt> Class: class of interest
  #
  # === Return:
  #
  # Array: ids or Array of ids
  #
  def ids(clazz)
    class_sym = clazz.name.to_sym
    @cache = {} if @cache.nil?
    ids = @cache[class_sym]
    return ids unless ids.nil?
    ids = case class_sym
          when :Candidate
            Candidate.pluck(:id, :baptismal_certificate_id, :candidate_sheet_id, :christian_ministry_id,
                            :pick_confirmation_name_id, :retreat_verification_id, :sponsor_covenant_id)
          when :BaptismalCertificate
            BaptismalCertificate.pluck(:id, :church_address_id, :scanned_certificate_id)
          when :CandidateSheet
            CandidateSheet.pluck(:id, :address_id)
          when :RetreatVerification
            RetreatVerification.pluck(:id, :scanned_retreat_id)
          when :SponsorCovenant
            SponsorCovenant.pluck(:id, :scanned_covenant_id, :scanned_eligibility_id)
          when :ToDo
            ToDo.pluck(:id, :confirmation_event_id, :candidate_event_id)
          else
            clazz.pluck(:id)
          end
    @cache[class_sym] = ids
    ids
  end

  # Orphaned ids for clazz
  #
  # === Parameters:
  #
  # * <tt>:clazz</tt> Class: class of interest
  # * <tt>:used_ids</tt> Array: of ids - ids of clazz used by parent
  # * <tt>:_offset_</tt>  If present used to offset the ids of clazz (i.e. clazz_id iss an array)
  #
  # === Return:
  #
  # Array: ids
  #
  def orphaned_ids(clazz, used_ids, offset = nil)
    if offset.nil?
      ans = ids(clazz).select { |bc_id| used_ids.select { |used_id| used_id == bc_id }.empty? }
    else
      ans = ids(clazz).select do |clazz_id|
        used_ids.select do |used_id|
          used_id == clazz_id[offset]
        end.empty?
      end
      ans = ans.map { |x| x[offset] }
    end
    ans
  end

  # Walks through the associations searching for associations that are created but not associated with parent
  #
  # === Return:
  #
  # CandidateImport: self
  #
  def add_orphaned_table_rows
    begin
      cand_ids = ids(Candidate)
      orphaned_table_rows = { BaptismalCertificate: orphaned_baptismal_certificates(cand_ids) }
      orphaned_table_rows[:CandidateSheet] = orphaned_candidate_sheets(cand_ids)
      orphaned_table_rows[:ChristianMinistry] = orphaned_christian_ministry(cand_ids)
      orphaned_table_rows[:PickConfirmationName] = orphaned_pick_name(cand_ids)
      orphaned_table_rows[:RetreatVerification] = orphaned_retreat_verification(cand_ids)
      orphaned_table_rows[:SponsorCovenant] = orphaned_sponsor_covenant(cand_ids)
      orphaned_table_rows[:Address] = orphaned_addresses
      orphaned_table_rows[:ScannedImage] = orphaned_scanned_image
      orphaned_table_rows[:ToDo] = orphaned_to_do
    rescue StandardError => e
      Rails.logger.info 'error while looking for orphans'
      Rails.logger.info e.message
      Rails.logger.info e.backtrace.inspect
      %i[BaptismalCertificate CandidateSheet ChristianMinistry PickConfirmationName RetreatVerification ¬SponsorCovenant Address ScannedImage ToDo].each do |key|
        orphaned_table_rows[key] = [:error] unless orphaned_table_rows[key]
      end
    end
    self
  end

  # Finds all the Address's that have been orphaned.
  def orphaned_addresses
    ids(Address).select do |ar_id|
      ids(BaptismalCertificate).map { |bc_info| bc_info[1] }.select { |church_address_id| church_address_id == ar_id }.empty? &&
        ids(CandidateSheet).map { |bc_info| bc_info[1] }.select { |address_id| address_id == ar_id }.empty?
    end
  end

  # Finds all the BaptismalCertificate's that have been orphaned.
  #
  # === Parameters:
  #
  # * <tt>:used_cand_ids</tt> Array:
  #
  # === Return:
  #
  # Array: ids
  #
  def orphaned_baptismal_certificates(used_cand_ids)
    orphaned_ids(BaptismalCertificate, (used_cand_ids.map { |x| x[1] }), 0)
  end

  # Finds all the ChristianMinistry's that have been orphaned.
  #
  # === Parameters:
  #
  # * <tt>:used_cand_ids</tt> Array:
  #
  # === Return:
  #
  # Array: ids
  #
  def orphaned_christian_ministry(cand_ids)
    orphaned_ids(ChristianMinistry, cand_ids.map { |x| x[3] })
  end

  # Finds all the CandidateSheet's that have been orphaned.
  #
  # === Parameters:
  #
  # * <tt>:used_cand_ids</tt> Array:
  #
  # === Return:
  #
  # Array: ids
  #
  def orphaned_candidate_sheets(cand_ids)
    orphaned_ids(CandidateSheet, cand_ids.map { |x| x[2] }, 0)
  end

  # Finds all the PickConfirmationName's that have been orphaned.
  #
  # === Parameters:
  #
  # * <tt>:used_cand_ids</tt> Array:
  #
  # === Return:
  #
  # Array: ids
  #
  def orphaned_pick_name(cand_ids)
    orphaned_ids(PickConfirmationName, cand_ids.map { |x| x[4] })
  end

  # Finds all the RetreatVerification's that have been orphaned.
  #
  # === Parameters:
  #
  # * <tt>:used_cand_ids</tt> Array:
  #
  # === Return:
  #
  # Array: ids
  #
  def orphaned_retreat_verification(cand_ids)
    orphaned_ids(RetreatVerification, cand_ids.map { |x| x[5] }, 0)
  end

  # Finds all the SponsorCovenant's that have been orphaned.
  #
  # === Parameters:
  #
  # * <tt>:used_cand_ids</tt> Array:
  #
  # === Return:
  #
  # Array: ids
  #
  def orphaned_sponsor_covenant(cand_ids)
    orphaned_ids(SponsorCovenant, cand_ids.map { |x| x[6] }, 0)
  end

  # Finds all the ScannedImage's that have been orphaned.
  def orphaned_scanned_image
    ids(ScannedImage).select do |ar_id|
      ids(BaptismalCertificate).map { |x| x[2] }.select { |scanned_certificate_id| scanned_certificate_id == ar_id }.empty? &&
        ids(RetreatVerification).map { |x| x[1] }.select { |scanned_retreat_id| scanned_retreat_id == ar_id }.empty? &&
        ids(SponsorCovenant).map { |x| x[1] }.select { |scanned_covenant_id| scanned_covenant_id == ar_id }.empty? &&
        ids(SponsorCovenant).map { |x| x[2] }.select { |scanned_eligibility_id| scanned_eligibility_id == ar_id }.empty?
    end
  end

  # Finds all the ScannedImage's that have been orphaned.
  def orphaned_to_do
    orphaned = ids(ToDo).select do |_todo_id, confirmation_event_id, candidate_event_id|
      ids(ConfirmationEvent).select { |ce_id| confirmation_event_id == ce_id }.empty? &&
        ids(CandidateEvent).select { |ce_id| candidate_event_id == ce_id }.empty?
    end
    orphaned.map { |id, _ce_id, _cand_id| id }
  end

  # test only
  # gets columns
  #
  # === Parameters:
  #
  # * <tt>:missing_events</tt> Array: of expected missing ConfirmationEvents
  #
  # === Return:
  #
  # CandidateImport: self
  #
  def xlsx_columns
    params = Candidate.permitted_params
    columns = []
    get_columns(params, columns)
    columns.delete(:password)
    columns.delete(:password_confirmation)
    ['baptismal_certificate.scanned_certificate', 'retreat_verification.scanned_retreat',
     'sponsor_covenant.scanned_eligibility', 'sponsor_covenant.scanned_covenant'].each do |base|
      ScannedImage.permitted_params.each do |not_exported|
        columns.delete("#{base}.#{not_exported}")
      end
    end
    (0..confirmation_events_sorted.length - 1).each do |index|
      columns << "candidate_events.#{index}.completed_date"
      columns << "candidate_events.#{index}.verified"
    end
    columns
  end

  # test only
  # Conifirmation Event columns
  #
  # === Return:
  #
  # Array: String
  #

  def xlsx_conf_event_columns
    %w[name index the_way_due_date chs_due_date instructions]
  end

  private

  # Get a candidate's CandidateEvent in order
  #
  # === Parameters:
  #
  # * <tt>:candidate</tt> Candidate:
  #
  # === Return:
  #
  # Array: of CandidateEvent
  #
  def candidate_events_in_order(candidate)
    events = []
    @events_in_order.each do |confirmation_event|
      events << candidate.get_candidate_event(confirmation_event.name)
    end
    events
  end

  def content_type(type)
    return type if type.blank?
    type.split('/')[1]
  end

  # return the
  #
  # === Parameters:
  #
  # * <tt>:candidate</tt> Candidate:
  # * <tt>:col</tt> String: image being processed
  # * <tt>:dir</tt> String: base file path
  # * <tt>:images</tt> Array: images processed
  #
  def certificate_image_column(candidate, col, dir, images)
    if col.include? 'scanned_certificate'
      image = candidate.baptismal_certificate.scanned_certificate
      unless image.nil?
        export_filename = CandidateImport.image_filepath_export(candidate, dir, 'scanned_certificate', image)
        images.append(export_filename: export_filename, image: image)
        "#{image.filename}:::#{content_type(image.content_type)}:::#{export_filename}"
      end
    elsif col.include? 'retreat_verification'
      image = candidate.retreat_verification.scanned_retreat
      unless image.nil?
        export_filename = CandidateImport.image_filepath_export(candidate, dir, 'scanned_retreat', image)
        images.append(export_filename: export_filename, image: image)
        "#{image.filename}:::#{content_type(image.content_type)}:::#{export_filename}"
      end
    elsif col.include? 'scanned_eligibility'
      image = candidate.sponsor_covenant.scanned_eligibility
      unless image.nil?
        export_filename = CandidateImport.image_filepath_export(candidate, dir, 'scanned_eligibility', image)
        images.append(export_filename: export_filename, image: image)
        "#{image.filename}:::#{content_type(image.content_type)}:::#{export_filename}"
      end
    elsif col.include? 'scanned_covenant'
      image = candidate.sponsor_covenant.scanned_covenant
      unless image.nil?
        export_filename = CandidateImport.image_filepath_export(candidate, dir, 'scanned_covenant', image)
        images.append(export_filename: export_filename, image: image)
        "#{image.filename}:::#{content_type(image.content_type)}:::#{export_filename}"
      end
    end
  end

  # adds ConfirmationEvents to a worksheet in the workbook
  #
  # === Parameters:
  #
  # * <tt>:wb</tt> Workbook: excel workbook.
  #
  def create_confirmation_event(wb)
    confirmation_event_columns = xlsx_conf_event_columns
    wb.add_worksheet(name: @worksheet_conf_event_name) do |sheet|
      sheet.add_row confirmation_event_columns
      confirmation_events_sorted.each_with_index do |confirmation_event, index|
        # puts "Event: #{confirmation_event.name} index:#{index}"
        sheet.add_row(confirmation_event_columns.map do |col|
          if col == 'index'
            index
          else
            # Rails.logger.info "xxx create_confirmation_event event:#{confirmation_event.name} instructions encoding: #{confirmation_event.send(col).encoding}" if col === 'instructions'
            confirmation_event.send(col)
          end
        end)
      end
    end
  end

  # create and fill in an Axlsx::Package
  #
  # === Parameters:
  #
  # * <tt>:dir</tt> String: base filepath
  #
  # === Return:
  #
  # Axlsx::Package:
  #
  def create_xlsx_package(dir, with_pictures)
    # http://www.rubydoc.info/github/randym/axlsx/Axlsx/Workbook:use_shared_strings
    p = Axlsx::Package.new(author: 'Admin')
    wb = p.workbook
    create_confirmation_event(wb)

    candidate_columns = xlsx_columns
    wb.add_worksheet(name: @worksheet_name) do |sheet|
      images = []
      sheet.add_row candidate_columns
      Candidate.order(:account_name).each do |candidate|
        Rails.logger.info "xxx create_xlsx_package processing candidate:#{candidate.account_name}"
        events = confirmation_events_sorted
        sheet.add_row(candidate_columns.map do |col|
          if CandidateImport.image_columns.include?(col)
            Rails.logger.info "   xxx create_xlsx_package Image:#{candidate.account_name} #{col}"
            certificate_image_column(candidate, col, dir, images)
          elsif CandidateImport.transient_columns.include?(col)
            # don't put these out in the spreadsheet they are associated with getting images to the server.
            Rails.logger.info "   xxx create_xlsx_package Transient:#{candidate.account_name} #{col}"
          else
            # puts col
            # Rails.logger.info "   xxx create_xlsx_package NOT Image:#{candidate.account_name} #{col}"
            val = get_column_value(candidate, col, events)
            # Rails.logger.info "col=#{col} val=#{val}"
            val
          end
        end)
      end
      write_export_images(images) if with_pictures
    end
    p
  end

  # get value to put in cell
  #
  # === Parameters:
  #
  # * <tt>:candidate</tt> Candidate:
  # * <tt>:col</tt> String:
  # * <tt>:confirmation_events</tt> Array:
  #
  # === Return:
  #
  # Object: self
  #
  def get_column_value(candidate, col, confirmation_events)
    split = col.split('.')
    case split.size
    when 1
      candidate.send(col)
    when 2
      candidate_send0 = candidate.send(split[0])
      if candidate_send0.nil?
        nil
      else
        candidate_send0.send(split[1])
      end
    when 3
      if split[0] != 'candidate_events'
        candidate_send0 = candidate.send(split[0])
        if candidate_send0.nil?
          nil
        else
          candidate_send0.send(split[1]).send(split[2])
        end
      else
        confirmation_event = confirmation_events[split[1].to_i]
        cand_event = candidate.get_candidate_event(confirmation_event.name)
        cand_event.send(split[2])
      end
    else
      "Unexpected split size: #{split.size}"
    end
  end

  #
  #
  # === Parameters:
  #
  # * <tt>:params</tt> Array:
  # * <tt>:columns</tt> Array: column names
  # * <tt>:_prefix_</tt> String:  optional prefix to add to columns
  #
  def get_columns(params, columns, prefix = '')
    return columns if params.empty?
    params.each do |param|
      if param.is_a?(Hash)
        param.each_key do |key|
          next if key == :candidate_events_attributes
          key_str = key.to_s
          xxx = key_str[0, key_str.size - 11] # 11 = ('_attributes'.size)
          get_columns(param[key], columns, (prefix.empty? ? xxx : "#{prefix}.#{xxx}"))
        end
      else
        # no need to save id because it will get a new id when filed in.
        parameter = prefix.empty? ? param.to_s : "#{prefix}.#{param}"
        columns << parameter unless param == :id || CandidateImport.transient_columns.include?(parameter)
      end
    end
  end

  # return sorted array of ConfirmationEvent by name
  #
  # === Return:
  #
  # Array: ConfirmationEvent
  #
  def confirmation_events_sorted
    ConfirmationEvent.order(:name)
  end

  # process uploaded file
  #   uploaded_file:  an xlsx file with some initial candidate information
  #   uploaded_zip_file:  created by exporting the DB tables
  #
  def load_imported_candidates
    # uploaded_file is an xlsx, either initial file or an exported file.
    if uploaded_file
      candidates = []
      @candidate_to_row = {}
      spreadsheet = open_spreadsheet
      if spreadsheet.sheets[0] == @worksheet_name || spreadsheet.sheets[0] == @worksheet_conf_event_name
        process_exported_xlsx(candidates, spreadsheet)
      else
        process_initial_xlsx(candidates, spreadsheet)
      end
      spreadsheet.close
      candidates
    elsif uploaded_zip_file
      # zipped dir with xlsx and images.  this was generated via an export.
      # once expanded then set uploaded_file and recurse
      process_xlsx_zip
    end
  end

  # read in spreadsheet from given file.
  #
  # === Return:
  #
  # Roo::Excelx:
  #
  def open_spreadsheet
    is_zip = !uploaded_file.respond_to?(:original_filename)
    path = is_zip ? uploaded_file : uploaded_file.path
    case File.extname(is_zip ? File.basename(uploaded_file) : uploaded_file.original_filename)
    when '.xlsx' then
      spreadsheet = Roo::Excelx.new(path, file_warning: :ignore)
      spreadsheet.header_line = 1
      spreadsheet.default_sheet = spreadsheet.sheets[0]
      spreadsheet
      # Axlsx::Workbook.new(path)
    else
      raise "Unknown file type: #{uploaded_file.original_filename}"
    end
  end

  # process/create Candidates based on spreadsheet and add to candidates
  #
  # === Parameters:
  #
  # * <tt>:candidates</tt> Array: Candidate created
  # * <tt>:spreadsheet</tt> Roo::Excelx: read in.
  #
  def process_candidates(candidates, spreadsheet)
    sheet = spreadsheet.sheet(@worksheet_name)
    header_row = sheet.row(1)
    account_name_index = header_row.find_index { |cell| cell == 'account_name' }
    (2..spreadsheet.last_row).each do |i|
      row = sheet.row(i)

      candidate = Candidate.find_by(account_name: row[account_name_index]) || AppFactory.create_candidate
      events = candidate_events_in_order(candidate)
      row.each_with_index do |cell, index|
        column_name_split = header_row[index].split('.')
        # puts header_row[index]
        unless cell.nil?
          if column_name_split.size == 1
            candidate.send("#{column_name_split[0]}=", cell)

          elsif column_name_split.size == 2
            case column_name_split[1]

            when 'scanned_certificate'
              candidate.baptismal_certificate.scanned_certificate = create_scanned_image(cell)
            when 'scanned_retreat'
              candidate.retreat_verification.scanned_retreat = create_scanned_image(cell)
            when 'scanned_eligibility'
              candidate.sponsor_covenant.scanned_eligibility = create_scanned_image(cell)
            when 'scanned_covenant'
              candidate.sponsor_covenant.scanned_covenant = create_scanned_image(cell)
            else
              candidate.baptismal_certificate.create_church_address if column_name_split[1] == 'church_address' && candidate.baptismal_certificate.church_address.nil?
              candidate_send0 = candidate.send(column_name_split[0])
              candidate_send0.send("#{column_name_split[1]}=", cell)
            end

          elsif column_name_split.size == 3 && column_name_split[0] != 'candidate_events'
            candidate.baptismal_certificate.create_church_address if column_name_split[1] == 'church_address' && candidate.baptismal_certificate.church_address.nil?
            candidate_send0 = candidate.send(column_name_split[0])
            if candidate_send0.nil?
              nil
            else
              candidate_send__send = candidate_send0.send(column_name_split[1])
              candidate_send__send.send("#{column_name_split[2]}=", cell)
            end
          elsif column_name_split.size == 3
            events[column_name_split[1].to_i].send("#{column_name_split[2]}=", cell)
          end
        end
      end
      candidate.password = Event::Other::INITIAL_PASSWORD
      candidates.push(candidate)
    end
  end

  # create ScannedImage from cell
  #
  # === Parameters:
  #
  # * <tt>:cell</tt> String:  cell value
  #
  # === Return:
  #
  # ScannedImage:
  #
  def create_scanned_image(cell)
    image_filename, image_content_type, export_filename = cell.split(':::')
    scanned_image = ScannedImage.new
    scanned_image.filename = image_filename
    scanned_image.content_type = "image/#{image_content_type}"
    File.open(export_filename, 'rb') do |f|
      scanned_image.content = f.read
    end
    scanned_image
  end

  # Create ConfirmationEvents and add to @events_in_order
  #
  # === Parameters:
  #
  # * <tt>:spreadsheet</tt> Roo::Excelx
  #
  def process_confirmation_events(spreadsheet)
    @events_in_order = []
    sheet = spreadsheet.sheet(@worksheet_conf_event_name)
    header_row = sheet.row(1)
    name_index = header_row.find_index { |cell| cell == 'name' }
    (2..spreadsheet.last_row).each do |i|
      row = sheet.row(i)
      confirmation_event = ConfirmationEvent.find_by(name: row[name_index]) || AppFactory.add_confirmation_event(row[name_index])
      row.each_with_index do |cell, index|
        column_name_split = header_row[index].split('.')
        next if cell.nil?
        next if column_name_split[0] == 'index'
        confirmation_event.send("#{column_name_split[0]}=", cell)
      end
      confirmation_event.save
      @events_in_order << confirmation_event
      # puts "#{i-2}: #{confirmation_event.name}:#{confirmation_event.the_way_due_date.to_s}:#{confirmation_event.chs_due_date.to_s}"
    end
  end

  # process spreadsheet & update candidates
  #
  # === Parameters:
  #
  # * <tt>:candidates</tt> Array: of Candidate created.
  # * <tt>:spreadsheet</tt> Roo::Excelx
  #
  def process_exported_xlsx(candidates, spreadsheet)
    process_confirmation_events(spreadsheet)

    process_candidates(candidates, spreadsheet)
  end

  # export ScannedImages
  #
  # === Parameters:
  #
  # * <tt>:images</tt> Array: ScannedImages to export
  #
  # === Return:
  #
  # CandidateImport: self
  #
  def write_export_images(images)
    images.each do |entry|
      export_filename = entry[:export_filename]
      image = entry[:image]
      begin
        File.open(export_filename, 'wb') do |f|
          f.write image.content
        end
      rescue StandardError => e
        Rails.logger.info "Exception opening file for image: #{export_filename}"
        Rails.logger.info "Error message #{e.message}"
        Rails.logger.info e.backtrace.inspect
      end
    end
  end

  # Create Candidate with some initial information
  #
  # === Parameters:
  #
  # * <tt>:candidates</tt> Array: updated with created Candidate
  # * <tt>:spreadsheet</tt> Roo::Excelx
  #
  # === Return:
  #
  # Array: candidates
  #
  def process_initial_xlsx(candidates, spreadsheet)
    header_row = spreadsheet.first
    if header_row[0].strip == 'Last Name' &&
       header_row[1].strip == 'First Name' &&
       header_row[2].strip == 'Grade' &&
       header_row[3].strip == 'Teen Email' &&
       header_row[4].strip == 'Parent Email Address(es)' &&
       header_row[5].strip == 'Cardinal Gibbons HS Group'

      (2..spreadsheet.last_row).each do |i|
        spreadsheet_row = spreadsheet.row(i)

        next if spreadsheet_row[0].nil? && spreadsheet_row[1].nil? && spreadsheet_row[2].nil? && spreadsheet_row[3].nil? # skip empty row

        last_name = spreadsheet_row[0].nil? ? '' : spreadsheet_row[0].strip
        first_name = spreadsheet_row[1].nil? ? '' : spreadsheet_row[1].strip
        grade = if spreadsheet_row[2].class.to_s == 'Fixnum'
                  (spreadsheet_row[2].nil? ? '10th' : "#{spreadsheet_row[2]}th")
                else
                  (spreadsheet_row[2].nil? ? '10th' : spreadsheet_row[2].strip)
                end
        candidate_email = spreadsheet_row[3].nil? ? '' : spreadsheet_row[3].strip
        parent_email = spreadsheet_row[4].nil? ? '' : spreadsheet_row[4].strip
        cardinal_gibbons = spreadsheet_row[5].nil? ? '' : spreadsheet_row[5].strip

        candidate_sheet_params = ActionController::Parameters.new
        params = ActionController::Parameters.new(candidate: ActionController::Parameters.new(candidate_sheet_attributes: candidate_sheet_params))

        candidate_sheet_params[:last_name] = last_name
        candidate_sheet_params[:first_name] = first_name
        candidate_sheet_params[:grade] = grade.empty? ? 10 : grade.slice(/^\D*[\d]*/)
        clean_item = ActionView::Base.full_sanitizer.sanitize(candidate_email)
        unless clean_item.empty?
          candidate_sheet_params[:candidate_email] = clean_item
        end
        clean_item = ActionView::Base.full_sanitizer.sanitize(parent_email)
        unless clean_item.empty?
          item_split = clean_item.split(',')
          candidate_sheet_params[:parent_email_1] = item_split[0].strip
          candidate_sheet_params[:parent_email_2] = item_split[1].strip if item_split.size > 1
        end
        candidate_sheet_params[:attending] = cardinal_gibbons.empty? ? I18n.t('views.candidates.attending_the_way') : I18n.t('model.candidate.attending_catholic_high_school')

        account_name = String.new(candidate_sheet_params[:last_name].gsub(/\s+/, '') || '').concat(candidate_sheet_params[:first_name].gsub(/\s+/, '') || '').downcase
        params[:candidate][:account_name] = account_name
        params[:candidate][:password] = Event::Other::INITIAL_PASSWORD

        candidate = Candidate.find_by(account_name: account_name) || ::AppFactory.create_candidate
        candidate.update_attributes(params.require(:candidate).permit(Candidate.permitted_params))
        candidates.push(candidate)
        @candidate_to_row[candidate] = i
      end
      candidates
    else
      raise "Unknown spread sheet columns: #{header_row}"
    end
  end

  # expand zip file and the process xlsx
  def process_xlsx_zip
    dir = 'xlsx_export'

    delete_dir(dir)

    begin
      Dir.mkdir(dir)

      Zip::File.open(uploaded_zip_file.tempfile) do |zip_file|
        # Handle entries one by one
        zip_file.each do |entry|
          # Extract to file/directory/symlink
          # puts "Extracting #{entry.name}"
          entry.extract("#{dir}/#{entry.name}")
          if File.extname(entry.name) == '.xlsx' && @uploaded_file.nil?
            @uploaded_file = "#{dir}/#{entry.name}"
          end
        end
      end
      load_imported_candidates
    ensure
      delete_dir(dir)
    end
  end

  # Removes all ConfirmationEvent
  def remove_all_confirmation_events
    ConfirmationEvent.find_each(&:delete)
  end

  # Make sure all candidates are valid before saving.
  #
  # === Return:
  #
  #
  # Boolean:
  #
  def validate_and_save_import
    if imported_candidates.map do |cand|
      cand.valid?
      cand.candidate_sheet.validate_emails # no longer part of save
      cand.errors.none?
    end.all?
      imported_candidates.each(&:save!)
      true
    else
      imported_candidates.each do |candidate_import|
        candidate_import.candidate_sheet.errors.full_messages.each do |message|
          errors.add :base, "Row #{@candidate_to_row[candidate_import]}: #{message}"
        end
      end
      false
    end
  end
end
